# emacs: -*- mode: python; py-indent-offset: 4; indent-tabs-mode: nil -*-
# ex: set syntax=python:
# vim: ft=python
# NIpy buildBOT Master Instance config
#
# [ TODO ]      (in no particular order)
# - combine multiple steps into one (if possible)
# - rename steps to be more concise and informative
# - generate numpy version based templates
# - what's up with the buildout not using ~/.buildout/default.cfg and not caching
#       * we may need to set some properties for this to work
# - install more versions of python on the slaves
# - have slaves report back their configuration (so we have them doing the right builders)
# - if possible, forcebuild every builder on a particular slave (to check that it can)
# - hookup with git post-commit hooks (instead of relying on poller)

""" A brief tour of buildbot

To remind myself

A ChangeSource looks for Changes.

In our case we are using GitPoller ChangeSource to look for changes in our git
repositories.

When ChangeSource finds changes, it broadcasts them to all Schedulers.  Each
Scheduler must decide if it wants to react to a Change.  It generally does this
by filtering changes to select changes it will act on.

We use SingleBranchSchedulers for this.  These obviously respond only to
changes in one branch of a repository.  If .scheduler() provided with multiple
branches, AnyBranchScheduler is used.

A BuildSet is the association of (information about what changes need to be
tested) and (Builders on which to test)

If a Scheduler selects changes for action, it sends BuildSets to the system
(the BuildMaster).  Therefore, a Scheduler needs to know its Builders. It gets
these by name (string).

For each BuildSet, the (changes to be tested) are sent to each Builder.  Each
of these requests is BuildRequest.

A Builder accepts a BuildRequest and runs it on a BuildSlave.  It does this by
using its own BuildFactory instance to make Builds.

A Builder can have more than one associated BuildSlave.  In this case each
associated BuildSlave is assumed to produce identical results, and the Builder
can therefore choose at whim which BuildSlave to use.

A Build has one or more Steps that should be run with a given (changes to be
tested).

One type of build Step is a Trigger, which activates a triggerable Scheduler,
which can react any way it likes, including sending further BuildSets.
"""

from os.path import join as pjoin

# This is convenient for splitting sh commands into lists
import shlex

# Buildbot objects
from buildbot.locks import MasterLock
from buildbot.buildslave import BuildSlave
from buildbot.changes.gitpoller import GitPoller
from buildbot.schedulers.filter import ChangeFilter
from buildbot.schedulers.forcesched import (ForceScheduler,
                                            FixedParameter,
                                            ChoiceStringParameter,
                                            StringParameter)
from buildbot.schedulers.basic import SingleBranchScheduler, AnyBranchScheduler
from buildbot.schedulers import timed
from buildbot.schedulers.triggerable import Triggerable
from buildbot.process.factory import BuildFactory
from buildbot.steps.source.git import Git
from buildbot.steps.shell import ShellCommand, SetPropertyFromCommand
from buildbot.steps.master import SetProperty
from buildbot.steps.transfer import FileDownload, DirectoryUpload
from buildbot.steps.trigger import Trigger
from buildbot.process.properties import Property, Interpolate
from buildbot.process import properties
from buildbot.config import BuilderConfig

# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

####### BUILDSLAVES

# Get passwords from file not in repository.  `slave_pass.py` defines a dict,
# `slave_passes` with key, value pairs defining (slave_name, slave_password)
import slave_pass as s_p
reload(s_p)
# Check that slave names are unique
if len(set(s_p.slave_passes)) != len(s_p.slave_passes):
    raise ValueError('Slave names must be unique')

experimental = ['pi-ApxuMed',]

linux_64_slaves = ['tom-standard']
linux_32_slaves = ['bongoslave']
debian_ppc_slaves = ['debian-ppc-32']
sparc_slaves_sid = ['nd-bb-slave-sparc-sid']
sparc_slaves_wheezy = ['nd-bb-slave-sparc-wheezy']
sparc_slaves = ['nd-bb-slave-sparc']
osx_leopard_ppc_slaves = ['osx-10.5-ppc']
osx_tiger_ppc_slaves = ['osx-mini']
osx_leopard_intel_slaves = ['osx-10.5']
osx_snowleopard_slaves = ['osx-10.6']
osx_lion_slaves = ['osx-10.7']
osx_mountainlion_slaves = ['osx-10.8']
xp_32_slaves = ['xp-mini']
win7_64_slaves = ['mike-win7-64']
arm_slaves = ['arm-raspberry-pi']
fedora_slaves = ['i20-fed19']

# Locks to prevent resource exhaustion which might need to be defined
# for some slaves.  It seems that locks need to be given to BuildSlave
# at __init__ time, so let's construct the mapping first: slave -> [locks]
# which are later used while initiating BuildSlave's
def add_lock(slave_locks, slavenames, lock, *accessargs):
    """Add a LockAccess's to a lock to the list of slaves
    """
    for name in slavenames:
        if not (name in slave_locks):
            slave_locks[name] = []
        slave_locks[name].append(lock.access(*accessargs))

slave_locks = {}

# vagus sparc box has only 4 CPUs, thus we should not run more than 4
# jobs in parallel
add_lock(slave_locks,
         sparc_slaves_sid + sparc_slaves_wheezy + sparc_slaves,
         MasterLock("vagus", maxCount=4), 'counting')

# The 'slaves' list defines the set of recognized buildslaves. Each element is
# a BuildSlave object, specifying a unique slave name and password.  The same
# slave name and password must be configured on the slave.
slaves = [BuildSlave(slave_name, slave_pass, locks=slave_locks.get(slave_name, None))
    for slave_name, slave_pass in s_p.slave_passes.items()]

# slave names must be unique
c['slaves'] = slaves

# 'slavePortnum' defines the TCP port to listen on for connections from slaves.
# This must match the value configured into the buildslaves (with their
# --master option)
c['slavePortnum'] = 9989

def sanitize_branch_name(name):
    return name.replace('/', '+')

# Helper functions and constants
class GithubBot(object):
    """ Class to make buildbot stuff based round a github repo
    """

    def __init__(self,
                 organization,
                 repo,
                 test_cmd,
                 doc_build_cmd=None,
                 built_doc_src=None,
                 easy_depends=(), # careful with easy_install and system packages
                 pip_depends=(),
                 # careful with easy_install and system packages
                 doc_easy_depends=(),
                 doc_pip_depends=('sphinx',),
                 src_subdir=None,
                 download_dir=None,
                 build_timeout=None,
                 test_env=None,
                 test_dir=None,
                 branches=["master"],
                 ):
        # using easy_install on packages that are already in
        # system-site-packages causes the system path to get promoted above the
        # virtualenv path, and usually causes a terrible mess.  so prefer pip
        # if at all possible.
        self.organization = organization
        self.repo = repo
        self.git_url = "git://github.com/%s/%s.git" % (organization, repo)
        self.test_cmd = test_cmd
        self.test_env = test_env
        self.test_dir = test_dir
        self.doc_build_cmd = doc_build_cmd
        self.built_doc_src = built_doc_src
        # Dependencies for install / test
        self.easy_depends = easy_depends # easy_install installs
        self.pip_depends = pip_depends # pip
        self.doc_easy_depends = doc_easy_depends # easy_installs for docs
        self.doc_pip_depends = doc_pip_depends # pip installs for docs
        self.src_subdir = src_subdir # Subdirectory containing source
        if download_dir is None:
            download_dir = '%s-dist' % repo
        self.download_dir = download_dir
        self.build_timeout = build_timeout
        self.branches = branches

    @property
    def project(self):
        return "%s" % (self.repo,)

    def poller(self, branches=None, interval=300):
        if branches is None:
            branches = self.branches
        return GitPoller(
            self.git_url,
            project=self.project,
            category=self.project,
            workdir = "%s-%s-%s" % (self.organization, self.repo, sanitize_branch_name('_'.join(branches))),
            branches=branches,
            pollinterval=interval)

    def scheduler(self, buildernames, branches=None):
        if isinstance(buildernames, basestring):
            buildernames = [buildernames]
        if branches is None:
            branches = self.branches
        if len(branches) > 1:             # each branch must have its own builder
            buildernames = ['%s_%s' % (n, b)
                            for n in buildernames
                            for b in branches]
        name = self.project
        if branches is not None:
            cf_kwargs = {'branch_fn': lambda branch: branch in branches}
            Scheduler = AnyBranchScheduler
        else:
            cf_kwargs = {}
            Scheduler = SingleBranchScheduler
        changefilter = ChangeFilter(repository=self.git_url,
                                    project=self.project,
                                    category=self.project,
                                    **cf_kwargs)
        return Scheduler(name=name,
                         change_filter=changefilter,
                         treeStableTimer=None,
                         builderNames=buildernames)

    def nightly_scheduler(self,
                          buildernames,
                          name_suff,
                          hour = 2, minute = 23,
                          ifchanged=True,
                          branch='master',
                         ):
        """ Make a timed scheduler for this repo """
        if isinstance(buildernames, basestring):
            buildernames = [buildernames]
        name = "%s-%s-nightly-%s" % (self.organization, self.repo, name_suff)
        changefilter = ChangeFilter(repository=self.git_url,
                                    project=self.project,
                                    category=self.project)
        return timed.Nightly(name=name,
                branch=branch,
                builderNames=buildernames,
                change_filter=changefilter,
                hour=hour,
                minute=minute,
                onlyIfChanged=ifchanged)

    def _easy_install(self, factory, easy_depends, env, workdir):
        for pkg_spec in easy_depends:
            if isinstance(pkg_spec, basestring):
                pkg_spec = [pkg_spec]
            cmd = ['easy_install'] + list(pkg_spec)
            factory.addStep(ShellCommand(command=cmd, env=env, workdir=workdir))

    def _pip_install(self, factory, pip_depends, env, workdir):
        for pkg_spec in pip_depends:
            # We need the 'ignore-installed' flag to force pip to install the
            # programs in the virtualenv.  Otherwise pip finds the programs
            # (like 'nose') already installed; these then call the system
            # python and we don't get the virtualenv python.
            if isinstance(pkg_spec, basestring):
                pkg_spec = [pkg_spec]
            cmd = ['pip', 'install', '--ignore-installed']  # fresh install
            factory.addStep(ShellCommand(command=cmd + list(pkg_spec),
                        env=env, workdir=workdir))

    def _make_virtualenv(self, factory, python=None):
        # Obviously requires virtualenv on the slave
        venv_params = ['--distribute', '--system-site-packages', 'venv']
        if not python is None:
            venv_params = ['--python=' + python] + venv_params
        factory.addStep(ShellCommand(command=['virtualenv'] + venv_params))
        # Now we need the venv binary directory
        factory.addStep(FileDownload('slave_scripts/bs_tools.py',
                                     'bs_tools.py'))
        factory.addStep(SetPropertyFromCommand(command=shlex.split(
            'python bs_tools.py path-prepend-str venv'),
            property='venv_script_dir'))
        factory.addStep(SetPropertyFromCommand(command=shlex.split(
            'python bs_tools.py abspath venv'),
            property='venv_dir'))
        # Set env, with virtualenv in front of the path
        env={'PATH': Interpolate("%(prop:venv_script_dir)s${PATH}")}
        workdir = Interpolate("%(prop:venv_dir)s")
        venv_script_dir = Interpolate("%(prop:venv_script_dir)s")
        # Upgrade setuptools and pip if necessary for wheel installs
        # Can't install pip with pip because it can't delete itself
        factory.addStep(ShellCommand(
            command=['easy_install', '-U', 'pip>=1.4'],
            env=env,
            workdir=venv_script_dir))
        # Can't install easy_install with easy_install because it can't delete
        # itself.  Use the bootstrap script to avoid version conflict problems
        # from setuptools' nuclear path behavior.
        factory.addStep(ShellCommand(
            command = ['python', 'bs_tools.py', 'get-url',
            'https://bitbucket.org/pypa/setuptools/raw/bootstrap/ez_setup.py',
            'ez_setup.py']))
        factory.addStep(ShellCommand(
            command=['python', 'ez_setup.py'],
            env=env))
        return env, workdir, venv_script_dir

    def _code_build_factory(self,
                            python=None,
                            easy_depends=None,
                            pip_depends=None,
                            pre_build_cmds=(),
                            branch=None):
        if easy_depends is None:
            easy_depends = self.easy_depends
        if pip_depends is None:
            pip_depends = self.pip_depends
        factory = BuildFactory()
        git_kwargs = {'branch': branch} if branch is not None else {}
        factory.addStep(Git(repourl=self.git_url, mode='full', retry=(15, 5), **git_kwargs))
        # Make virtualenv, return environment, workdir of venv
        my_env, workdir, venv_script_dir = self._make_virtualenv(factory, python)
        # Any pre-building commands
        for cmd in pre_build_cmds:
            factory.addStep(ShellCommand(command=cmd))
        # Add install and runtime dependencies
        self._easy_install(factory, easy_depends, my_env, workdir=venv_script_dir)
        self._pip_install(factory, pip_depends, my_env, workdir=venv_script_dir)
        # Work out working directory for install
        if not self.src_subdir is None:
            factory.addStep(SetPropertyFromCommand(command=[
                'python', 'bs_tools.py', 'abspath', self.src_subdir],
                property='src_path'))
            build_workdir = Interpolate("%(prop:src_path)s")
        else:
            build_workdir = None
        return factory, my_env, workdir, build_workdir, venv_script_dir

    def factory(self,
                test_cmd=None,
                python=None,
                easy_depends=None,
                pip_depends=None,
                pre_build_cmds=(),
                post_cmds=(),
                test_env=None,
                test_dir=None,
                install_cmd=('python', 'setup.py', 'install'),
                install_wd=None,
                branch=None,
        ):
        if test_cmd is None:
            test_cmd = self.test_cmd
        if test_env is None:
            test_env = self.test_env
        if test_dir is None:
            test_dir = self.test_dir
        factory, env, workdir, build_workdir, venv_script_dir = \
          self._code_build_factory(
            python, easy_depends, pip_depends, pre_build_cmds, branch=branch)
        # Additional options for ShellCommands, if provided.  To not
        # rely on knowing internal logic (either handles None as the
        # default value), we explicitly construct a dictionary only
        # with the specified options
        kwargs = {}
        if self.build_timeout:
            kwargs['timeout'] = self.build_timeout
        # Install into virtualenv
        if install_wd is None:
            install_wd = build_workdir
        if install_cmd is not None:
            factory.addStep(ShellCommand(
                command=install_cmd,
                env=env,
                workdir=install_wd,
                **kwargs))
        # Test
        if test_env:
            env = dict(env.items() + test_env.items())
        if test_dir:
           # allow for interpolations using known know variables
           test_dir_env = {'workdir': workdir, 'build_workdir': build_workdir}
           test_dir_env.update(env)
           test_dir = test_dir % test_dir_env
        else:
            test_dir = workdir
        if isinstance(test_cmd, dict):
            # must be mapping branches to test_cmd
            test_cmd = test_cmd[branch]
        factory.addStep(ShellCommand(command=test_cmd,
            env=env, workdir=test_dir, **kwargs))
        for cmd in post_cmds:
            factory.addStep(ShellCommand(command=shlex.split(cmd, posix=True),
                                         env=env, workdir=workdir, **kwargs))
        return factory

    def bdist_factory(self,
                      bdist_type,
                      test_cmd=None,
                      python=None,
                      easy_depends=None,
                      pip_depends=None,
                      pre_build_cmds=()):
        if test_cmd is None:
            test_cmd = self.test_cmd
        factory, env, workdir, build_workdir, venv_script_dir = \
          self._code_build_factory(
            python, easy_depends, pip_depends, pre_build_cmds)
        # Build binary format(s)
        if python is None: # Use virtualenv python
            my_python = 'python'
            build_env = env
        else: # Use specified python
            my_python = python
            # Insert virtualenv into PYTHONPATH for building using virtualenv
            # dependencies
            factory.addStep(SetPropertyFromCommand(command=shlex.split(
                'python bs_tools.py get-python-lib'),
                property='venv_python_lib', env=env))
            build_env = env.copy()
            build_env['PYTHONPATH'] = Interpolate("%(prop:venv_python_lib)s")
        if bdist_type == 'egg':
            factory.addStep(ShellCommand(
                command=[my_python, 'setup.py', 'bdist_egg'],
                env=build_env,
                workdir=build_workdir))
            # Make a mpkg for good measure
            factory.addStep(ShellCommand(
                command=[my_python, 'setup.py', 'bdist_mpkg'],
                env=build_env,
                workdir=build_workdir))
            installer = ['easy_install']
        elif bdist_type == 'exe':
            factory.addStep(ShellCommand(
                command=[my_python, 'setup.py', 'bdist', '--formats=wininst'],
                env=build_env,
                workdir=build_workdir))
            installer = ['easy_install']
        elif bdist_type == 'whl':
            # Install bdist_wheel command
            self._pip_install(factory,
                    ("wheel>=0.21",),
                    env=build_env,
                    workdir=workdir)
            # Make wheel - always use virtualenv python
            factory.addStep(ShellCommand(
                command=['python', 'setup.py', 'bdist_wheel'],
                env=build_env,
                workdir=build_workdir))
            installer = ['pip', 'install']
        else:
            raise ValueError('What is this?: ' + bdist_type)
        # Find binary installer file
        factory.addStep(SetPropertyFromCommand(
            command=['python', 'bs_tools.py',
                     'glob', 'dist', '*.' + bdist_type],
            property='bdist_file'))
        # Install into virtualenv
        factory.addStep(ShellCommand(
            command = installer + [Interpolate('%(prop:bdist_file)s')],
            env=env))
        # Test
        factory.addStep(
            ShellCommand(
                command=test_cmd,
                env=env,
                workdir=workdir,
                haltOnFailure=True))
        # Upload
        factory.addStep(DirectoryUpload(slavesrc="dist",
                masterdest="public_html/" + self.download_dir))
        return factory

    def doc_factory(self,
                    doc_build_cmd=None,
                    built_doc_src=None,
                    doc_doctest_cmd=None):
        if doc_build_cmd is None:
            doc_build_cmd = self.doc_build_cmd
        if built_doc_src is None:
            built_doc_src = self.built_doc_src
        if None in (doc_build_cmd, built_doc_src):
            raise ValueError("Need defined build command and doc source")
        factory, my_env, workdir, build_workdir, venv_script_dir = \
          self._code_build_factory()
        # Install into virtualenv
        kwargs = {}
        if self.build_timeout:
            kwargs['timeout'] = self.build_timeout
        factory.addStep(ShellCommand(
            command=['python', 'setup.py', 'install'],
            env=my_env,
            workdir=build_workdir,
            **kwargs))
        # Add install and runtime dependencies
        self._easy_install(factory, self.doc_easy_depends, my_env, workdir=venv_script_dir)
        self._pip_install(factory, self.doc_pip_depends, my_env, workdir=venv_script_dir)
        if not doc_doctest_cmd is None:
            factory.addStep(ShellCommand(command=doc_doctest_cmd, env=my_env))
        factory.addStep(ShellCommand(command=doc_build_cmd, env=my_env))
        factory.addStep(DirectoryUpload(slavesrc=built_doc_src,
                    masterdest="public_html/nightly/" + self.repo + '/doc'))
        return factory

    def build_builders(self, name_slavenames,
                       test_cmd=None,
                       python=None,
                       easy_depends=None,
                       pip_depends=None,
                       pre_build_cmds=(),
                       post_cmds=(),
                       install_cmd=('python', 'setup.py', 'install'),
                       install_wd=None,
                       branches=None,
                       ):
        if branches is None:
            branches = self.branches
        return sum([
            self._factory_builders(
                self.factory(test_cmd, python, easy_depends, pip_depends,
                             pre_build_cmds=pre_build_cmds, post_cmds=post_cmds,
                             install_cmd=install_cmd, install_wd=install_wd, branch=branch),
                name_slavenames,
                branch if len(branches)>1 else None)
            for branch in branches], [])

    def _factory_builders(self, factory, name_slavenames, branch=None):
        builders = []
        for name, slavelist in name_slavenames:
            if isinstance(slavelist, basestring):
                slavelist = [slavelist]
            if branch is not None:
                name='%s_%s' % (name, sanitize_branch_name(branch))
            builders.append(BuilderConfig(
                name=name,
                slavenames=slavelist,
                factory=factory))
        return builders

    def build_doc_builders(self,
            name_slavenames,
            doc_build_cmd=None,
            built_doc_src=None,
            doc_doctest_cmd=None):
        factory = self.doc_factory(doc_build_cmd, built_doc_src, doc_doctest_cmd)
        return self._factory_builders(factory, name_slavenames)


def nptest_command(pkg_name,
                   verbose=10,
                   doctests=False,
                   python='python',
                   cd=False,
                   stdout=False,
                   exe=False,
                   use_agg=False):
    """ Run tests from new directory """
    pystr = ''
    if cd:
        pystr += "import os; os.chdir('..');"
    if use_agg:
        pystr += 'import os; open("matplotlibrc", "wt").write("backend : agg"); '
    pystr += ("import sys; import %s; sys.exit(not %s.test(doctests=%s"
              % (pkg_name, pkg_name, doctests))
    if verbose != None:
        pystr += ', verbose=%d' % verbose
    if exe:
        pystr += ', extra_argv=["--exe"]'
    pystr += ").wasSuccessful())"
    return [python, '-c', "%s" % pystr]


nibabel_bot = GithubBot('nipy', 'nibabel',
    test_cmd = shlex.split('nosetests --verbosity=3 --exe --with-doctest nibabel nisext'),
    doc_build_cmd = "cd doc && make html",
    built_doc_src = "build/html",
    pip_depends = ('nose',)
)
nitime_bot = GithubBot('nipy', 'nitime',
    test_cmd = nptest_command('nitime', verbose=None),
    pip_depends = ('nose',)
)
pyarbus_bot = GithubBot('ivanov', 'pyarbus',
    test_cmd = nptest_command('pyarbus', verbose=None, use_agg=True),
    pip_depends = ('nose','nitime')
)
nipy_bot = GithubBot('nipy', 'nipy',
    test_cmd = nptest_command('nipy', doctests=True),
    doc_build_cmd = "cd doc && make dist",
    built_doc_src = "doc/dist",
    pip_depends = ('nose', 'sympy', 'nibabel')
)
dipy_bot = GithubBot('nipy', 'dipy',
    test_cmd = ['python', '-c',
    'import nose; '
    'from nose.plugins import doctests ;'
    'open("matplotlibrc", "wt").write("backend : agg"); '
    'argv = ["", "", "--with-doctest", "--verbosity=3", "--exe", "dipy"]; '
    'nose.core.TestProgram(argv=argv, addplugins=[doctests.Doctest()])'],
    pip_depends = ('nose', 'cython>=0.17', 'nibabel')
)
# dipy bot for linux machines with optional easy_depends and pip_depends that
# need an X window for testing
dipy_bot_nox = GithubBot('nipy', 'dipy',
    test_cmd = shlex.split('xvfb-run --auto-servernum --server-args="-screen 0 1024x768x24" nosetests --verbosity=3 --with-doctest dipy'),
    easy_depends = ('nose', 'nibabel')
)
nipype_bot = GithubBot('nipy', 'nipype',
    test_cmd = nptest_command('nipype', doctests=True),
    easy_depends = ('Traits',),
    pip_depends = ('nose', 'nibabel', 'networkx')
)
regreg_bot = GithubBot('regreg', 'regreg',
    test_cmd = shlex.split('nosetests --verbosity=3 --exe --with-doctest regreg'),
    pip_depends = ('nose',),
)
# pandas bot, primarily for sparc testing
pandas_bot = GithubBot('pydata', 'pandas',
    test_cmd = shlex.split('xvfb-run --auto-servernum --server-args="-screen 0 1024x768x24" nosetests --verbosity=3 --exe -s pandas'),
    doc_build_cmd = "make doc",
    built_doc_src = "doc/build/html",
    pip_depends = ('nose', 'apiclient',),
    build_timeout = 7200, # allow for its longer builds/testing especially for sparcs
)
# statsmodels bot, primarily for sparc testing
statsmodels_bot = GithubBot('statsmodels', 'statsmodels',
    test_cmd = shlex.split('xvfb-run --auto-servernum --server-args="-screen 0 1024x768x24" nosetests --verbosity=3 --exe -s statsmodels'),
    doc_build_cmd = "make -C docs html",
    built_doc_src = "docs/build",
    pip_depends = ('nose', 'patsy>=0.1.0',),
)
# pymvpa bot, primarily for sparc testing
pymvpa_bot = GithubBot('PyMVPA', 'PyMVPA',
    test_cmd = shlex.split('nosetests --verbosity=3 --exe -s mvpa2'),
    test_env = dict(MVPA_TESTS_LABILE='no', MVPA_MATPLOTLIB_BACKEND='agg', MVPA_TESTS_WTF='yes'),
    doc_build_cmd = "make htmldoc",
    built_doc_src = "build/html",
    pip_depends = ('nose',),
    build_timeout = 3600, # allow for its longer testing especially for sparcs.
)
# statsmodels bot, primarily for sparc testing
sklearn_bot = GithubBot('scikit-learn', 'scikit-learn',
    test_cmd = shlex.split('nosetests --verbosity=3 --exe -s sklearn'),
    doc_build_cmd = "make -C doc html",
    built_doc_src = "doc/build",
    easy_depends = ('nose',),
)
# Fail2Ban bots -- need separate ones for different branches because
# tests are invoked differently across them
fail2ban_bot = GithubBot('fail2ban', 'fail2ban',
    test_cmd = {'master': shlex.split('bin/fail2ban-testcases'),
                '0.8': shlex.split('./fail2ban-testcases')},
    branches = ['master', '0.8'],
    test_dir = './build/',
)

# Sympy
sympy_bot = GithubBot('sympy', 'sympy',
    test_cmd = ['python', '-c',
    'import sys; '
    'import sympy; '
    'open("matplotlibrc", "wt").write("backend : agg"); '
    'dt=sympy.doctest(); '
    't=sympy.test(); '
    'st=sympy.test(slow=True, verbose=True, timeout=2300); '
    'sys.exit(not (dt and t and st))'],
    doc_build_cmd = "make html-errors",
    pip_depends = (
        'gmpy==1.16',
        ('--no-deps', 'https://github.com/Theano/Theano/archive/master.zip')),
    doc_pip_depends = ('sphinx==1.1.3',),
    build_timeout = 2400, # allow for very slow sympy tests
)
# Numpy
numpy_bot = GithubBot('numpy', 'numpy',
    test_cmd = nptest_command('numpy', verbose=None),
    pip_depends = ('nose',),
                     )

####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.

#TODO: We should probably change the GitPoller to a PBChangeSource to react to
# commits http://buildbot.net/buildbot/docs/latest/manual/cfg-changesources.html#chsrc-PBChangeSource
c['change_source'] = [bot.poller() for bot in (nibabel_bot,
                                               nitime_bot,
                                               pyarbus_bot,
                                               nipy_bot,
                                               dipy_bot,
                                               nipype_bot,
                                               regreg_bot,
                                               statsmodels_bot,
                                               pymvpa_bot,
                                               sklearn_bot,
                                               sympy_bot,
                                               numpy_bot,
                                               fail2ban_bot,
                                               )]

# pandas is too expensive to test and overwhelmes the sparc box, so
# let's pull it much less frequently until figuring out how to
# implement **correct** locking
c['change_source'] += [pandas_bot.poller(interval=18000)]


####### SCHEDULERS
# Configure the Schedulers, which decide how to react to incoming changes.

c['schedulers'] = [
    nibabel_bot.scheduler(['nibabel-py2.6',
                           'nibabel-py2.6-32',
                           'nibabel-py2.6-xp',
                           'nibabel-py2.7-win7',
                           'nibabel-py2.6-squeeze-sparc',
                           'nibabel-py2.7-wheezy-sparc',
                           'nibabel-py2.x-sid-sparc',
                           'nibabel-py2.7-ppc',
                           'nibabel-py2.6-arm',
                           'nibabel-py2.7-fedora',
                           'nibabel-py2.7-osx-10.6',
                           'nibabel-py2.7-osx-10.7',
                           'nibabel-py2.7-osx-10.8',
                           'nibabel-py2.6-osx-10.5-ppc',
                           'nibabel-py2.6-osx-10.5-intel',
                           'nibabel-py3.2',
                           'nibabel-py3.3',
                           'nibabel-py2.7-pyd0.9.7',
                           'nibabel-py2.7-pyd0.9.8',
                          ]),
    nitime_bot.scheduler(['nitime-py2.6',
                          'nitime-py2.6-32',
                          'nitime-py2.6-xp',
                          'nitime-py2.6-arm',
                          'nitime-py2.7-fedora',
                          'nitime-py2.7-osx-10.6',
                          'nitime-py2.7-osx-10.7',
                          'nitime-py2.7-osx-10.8',
                          'nitime-py2.6-osx-10.5-ppc',
                          'nitime-py2.6-osx-10.5-intel',
                         ]),
    pyarbus_bot.scheduler(['pyarbus-py2.6',
                          ]),
    nipy_bot.scheduler(['nipy-py2.6',
                        'nipy-py2.6-32',
                        'nipy-py2.6-xp',
                        'nipy-py2.6-squeeze-sparc',
                        'nipy-py2.7-wheezy-sparc',
                        'nipy-py2.x-sid-sparc',
                        'nipy-py2.7-ppc',
                        'nipy-py2.6-arm',
                        'nipy-py2.7-fedora',
                        'nipy-py2.7-osx-10.6',
                        'nipy-py2.7-osx-10.7',
                        'nipy-py2.7-osx-10.8',
                        'nipy-py2.6-osx-10.5-ppc',
                        'nipy-py2.6-osx-10.5-intel',
                        'nipy-py3.2',
                        'nipy-py3.3',
                        'nipy-py2.7-sym0.7.0-nib1.2.0',
                       ]),
    dipy_bot.scheduler(['dipy-py2.6',
                        'dipy-py2.6-32',
                        'dipy-py2.6-xp',
                        'dipy-py2.6-squeeze-sparc',
                        'dipy-py2.7-wheezy-sparc',
                        'dipy-py2.x-sid-sparc',
                        'dipy-py2.6-arm',
                        'dipy-py2.7-fedora',
                        'dipy-py2.7-osx-10.6',
                        'dipy-py2.7-osx-10.7',
                        'dipy-py2.7-osx-10.8',
                        'dipy-py2.6-osx-10.5-ppc',
                        'dipy-py2.6-osx-10.5-intel',
                        'dipy-py3.2',
                        'dipy-py3.3',
                       ]),
    nipype_bot.scheduler(['nipype-py2.6',
                          'nipype-py2.6-32',
                          'nipype-py2.6-xp',
                          'nipype-py2.7-fedora',
                          'nipype-py2.7-osx-10.6',
                          'nipype-py2.7-osx-10.8',
                          'nipype-py2.6-osx-10.5-ppc',
                          'nipype-py2.6-osx-10.5-intel',
                       ]),
    regreg_bot.scheduler(['regreg-py2.6',
                          'regreg-py2.6-32',
                          'regreg-py2.6-xp',
                          'regreg-py2.7-fedora',
                          'regreg-py2.7-osx-10.6',
                          'regreg-py2.7-osx-10.7',
                          'regreg-py2.7-osx-10.8',
                          'regreg-py2.6-osx-10.5-ppc',
                          'regreg-py2.6-osx-10.5-intel',
                       ]),
    pandas_bot.scheduler([
                        'pandas-py2.x-sid-sparc',
                        'pandas-py3.x-sid-sparc',
                        'pandas-py2.6-wheezy-sparc',
                        'pandas-py2.7-wheezy-sparc',
                        'pandas-py3.x-wheezy-sparc',
                        ]),
    statsmodels_bot.scheduler([
                        'statsmodels-py2.x-sid-sparc',
                        # not yet
                        #'statsmodels-py3.x-sid-sparc',
                        'statsmodels-py2.7-wheezy-sparc',
                        #'statsmodels-py3.x-wheezy-sparc',
                        ]),
    pymvpa_bot.scheduler([
                        'pymvpa-py2.x-sid-sparc',
                        # not yet
                        #'pymvpa-py3.x-sid-sparc',
                        'pymvpa-py2.7-wheezy-sparc',
                        #'pymvpa-py3.x-wheezy-sparc',
                        'pymvpa-py2.7-osx-10.6',
                        'pymvpa-py2.7-osx-10.7',
                        'pymvpa-py2.7-osx-10.8',
                        'pymvpa-py2.6-osx-10.5-ppc',
                        'pymvpa-py2.6-osx-10.5-intel',
                        'pymvpa-py2.6-xp',
                        ]),
    fail2ban_bot.scheduler([
                        'fail2ban-py2.x-sid-sparc',
                        # whenever will add testing of 0.9
                        #'fail2ban-py3.x-sid-sparc',
                        'fail2ban-py2.7-wheezy-sparc',
                        #'fail2ban-py3.x-wheezy-sparc',
                        'fail2ban-py2.7-osx-10.6',
                        'fail2ban-py2.7-osx-10.8',
                        'fail2ban-py2.6-osx-10.5-ppc',
                        'fail2ban-py2.6-osx-10.5-intel',
                        'fail2ban-py2.7-ppc',
                        'fail2ban-py2.6-arm',
                        # needs more fixing
                        # 'fail2ban-py2.7-win7',
                        ]),
    sklearn_bot.scheduler([
                        'sklearn-py2.x-sid-sparc',
                        # not yet
                        #'sklearn-py3.x-sid-sparc',
                        'sklearn-py2.6-wheezy-sparc',
                        #'sklearn-py3.x-wheezy-sparc',
                        ]),
    numpy_bot.scheduler([
                        'numpy-py2.7-osx-10.8',
                        'numpy-py3.3-osx-10.8',
                        'numpy-py3.4-osx-10.8',
                        'numpy-py2.6-osx-10.5-ppc',
                        ]),
    # Doc builds
    nibabel_bot.nightly_scheduler(['nibabel-doc-builder'], 'doc', 2, 20, True),
    nipy_bot.nightly_scheduler(['nipy-doc-builder'], 'doc', 2, 01, True),
    pandas_bot.nightly_scheduler(['pandas-doc-builder'], 'doc', 2, 20, True),
    statsmodels_bot.nightly_scheduler(['statsmodels-doc-builder'], 'doc', 3, 20, True),
    pymvpa_bot.nightly_scheduler(['pymvpa-doc-builder'], 'doc', 4, 20, True),
    # Checks for easy_install and pip install
    # Windows 32 nightly builds
    nipy_bot.nightly_scheduler(['nipy-bdist32-26'], 'exe-26', 2, 10, True),
    nipy_bot.nightly_scheduler(['nipy-bdist32-27'], 'exe-27', 2, 20, True),
    nipy_bot.nightly_scheduler(['nipy-bdist32-32'], 'exe-32', 2, 30, True),
    nibabel_bot.nightly_scheduler(['nibabel-bdist32-27'],
                                  'exe-27', 2, 40, True),
    nibabel_bot.nightly_scheduler(['nibabel-bdist32-27-whl'],
                                  'whl-27', 2, 40, True),
    nibabel_bot.nightly_scheduler(['nibabel-bdist32-32'],
                                  'exe-32', 2, 50, True),
    # Windows 64 nightly builds
    nibabel_bot.nightly_scheduler(['nibabel-bdist64-26'],
                                  'exe64-26', 2, 00, True),
    # OSX nightlies
    nipy_bot.nightly_scheduler(['nipy-bdist-mpkg-2.7'], 'egg-27', 2, 20, True),
    nipy_bot.nightly_scheduler(['nipy-bdist-mpkg-3.3'], 'egg-33', 2, 30, True),
    # Dipy
    # Windows 32 nightly builds
    dipy_bot.nightly_scheduler(['dipy-bdist32-26'], 'dipy-exe-26', 3, 10, True),
    dipy_bot.nightly_scheduler(['dipy-bdist32-27'], 'dipy-exe-27', 3, 20, True),
    dipy_bot.nightly_scheduler(['dipy-bdist32-32'], 'dipy-exe-32', 3, 30, True),
    # OSX nightlies
    dipy_bot.nightly_scheduler(['dipy-bdist-mpkg-2.7'], 'dipy-egg-27', 3, 20, True),
    dipy_bot.nightly_scheduler(['dipy-bdist-mpkg-3.3'], 'dipy-egg-33', 3, 30, True),
    # Sympy slow build at night
    sympy_bot.nightly_scheduler(['sympy-py2.6-32'], 'sympy-slow', 2, 30, True),
    # Sympy binary builders
    sympy_bot.nightly_scheduler(['sympy-bdist32-27'],
                                  'exe-27', 5, 30, True),
    sympy_bot.nightly_scheduler(['sympy-bdist64-27'],
                                  'exe64-27', 5, 30, True),
    # Numpy binary builders
    numpy_bot.nightly_scheduler(['numpy-bdist-whl-osx-2.7'], 'whl-27', 5, 30, True),
    numpy_bot.nightly_scheduler(['numpy-bdist-whl-osx-3.3'], 'whl-33', 5, 30, True),
    numpy_bot.nightly_scheduler(['numpy-bdist-whl-osx-3.4'], 'whl-34', 5, 30, True),
]

# Some factories

def factory_buildout_nibabel(python='python2.6',numpy='1.6.1'):
    f = BuildFactory()
    # check out the source
    # XXX: the mastersrc should make appropriate changes based on numpy version
    f.addStep(Git(repourl='git://github.com/nipy/nibabel.git', mode='full'))
    f.addStep(FileDownload(mastersrc="bootstrap.py",
                                          slavedest="bootstrap.py"))
    f.addStep(FileDownload(mastersrc="nibabel_buildout.cfg",
                                          slavedest="buildout.cfg"))
    f.addStep(ShellCommand(command=[python, "bootstrap.py"]))
    f.addStep(ShellCommand(command=["bin/buildout"]))
    f.addStep(ShellCommand(nptest_command('nibabel',python='bin/buildoutpython')))
    # run the tests (note that this will require that 'nosetests' is installed)
    #f.addStep(nosetests_command('nibabel', doctests=True))
    return f


def shell_cmd_factory(git_url, cmds, posix=True):
    # Run a series of commands over a git repo
    factory = BuildFactory()
    factory.addStep(Git(
        repourl=git_url,
        mode='full', retry=(15, 5)))
    for cmd in cmds:
        factory.addStep(ShellCommand(command=shlex.split(cmd, posix=posix)))
    return factory


def example_factory(git_url, py_path, out_dir, python_cmd='python'):
    factory = BuildFactory()
    factory.addStep(Git(
        repourl=git_url,
        mode='full', retry=(15, 5)))
    # Touch c files to make sure build doesn't fail because of c file checkout
    # times
    factory.addStep(ShellCommand(command=shlex.split(
        'python tools/touch_cython_cs.py')))
    # Make virtualenv into which to install
    factory.addStep(
        ShellCommand(command=shlex.split(
            py_path + r'/bin/virtualenv --distribute --system-site-packages venv')
            ))
    # Install into virtualenv
    factory.addStep(
        ShellCommand(command=[python_cmd, 'setup.py', 'install'],
                     env={'PATH':
                          Interpolate("%(prop:workdir)s/build/venv/bin:${PATH}")}
            ))
    # Make directory for examples
    factory.addStep(
        ShellCommand(command=['mkdir', 'eg_logs']))
    # Run examples
    factory.addStep(
        ShellCommand(command=[
            python_cmd,
            '../tools/run_log_examples.py',
            '../examples',
            '--log-path=../eg_logs'],
            workdir=r'build/venv',
            env={'PATH': Interpolate("%(prop:workdir)s/build/venv/bin:${PATH}")}
            ))
    # Upload logs
    factory.addStep(DirectoryUpload(slavesrc="eg_logs",
            masterdest="public_html/" + out_dir))
    return factory

####### BUILDERS

# The 'builders' list defines the Builders, which tell Buildbot how to perform a build:
# what steps, and which slaves can execute them.  Note that any particular build will
# only take place on one slave.

c['builders'] = []
# nibabel exe builders
nibabel_test_cmd = shlex.split('nosetests --verbosity=3 --with-doctest nibabel')
c['builders'].append(BuilderConfig(
    name='nibabel-bdist32-27',
    slavenames=xp_32_slaves,
    factory=nibabel_bot.bdist_factory(
        'exe',
        test_cmd = nibabel_test_cmd,
        python = r'c:\Python27\python.exe')
))
c['builders'].append(BuilderConfig(
    name='nibabel-bdist32-27-whl',
    slavenames=xp_32_slaves,
    factory=nibabel_bot.bdist_factory(
        'whl',
        test_cmd = nibabel_test_cmd,
        python = r'c:\Python27\python.exe')
))
# The Python32 numpy 1.6.2 installation needs patching according to
# git diff ad9c2f4~1..ad9c2f4
# to remove use of __stdout__ and __stderr__ in numpy distutils
c['builders'].append(BuilderConfig(
    name='nibabel-bdist32-32',
    slavenames=xp_32_slaves,
    factory=nibabel_bot.bdist_factory(
        'exe',
        test_cmd = nibabel_test_cmd,
        python = r'c:\Python32\python.exe')
))
c['builders'].append(BuilderConfig(
    name='nibabel-bdist64-26',
    slavenames=win7_64_slaves,
    factory=nibabel_bot.bdist_factory(
        'exe',
        test_cmd = nibabel_test_cmd,
        python = r'c:\Python26\python.exe')
))
# nipy exe builders
nipy_test_cmd = nptest_command('nipy', doctests=True)
c['builders'].append(BuilderConfig(
    name='nipy-bdist32-26',
    slavenames=xp_32_slaves,
    factory=nipy_bot.bdist_factory(
        'exe',
        test_cmd = nipy_test_cmd,
        python = r'c:\Python26\python.exe',
        pre_build_cmds = [['python', r'tools\touch_cython_cs.py']])
))
c['builders'].append(BuilderConfig(
    name='nipy-bdist32-27',
    slavenames=xp_32_slaves,
    factory=nipy_bot.bdist_factory(
        'exe',
        test_cmd = nipy_test_cmd,
        python = r'c:\Python27\python.exe',
        pre_build_cmds = [['python', r'tools\touch_cython_cs.py']])
))
c['builders'].append(BuilderConfig(
    name='nipy-bdist32-32',
    slavenames=xp_32_slaves,
    factory=nipy_bot.bdist_factory(
        'exe',
        test_cmd = nipy_test_cmd,
        python = r'c:\Python32\python.exe',
        pre_build_cmds = [['python', r'tools\touch_cython_cs.py']])
))
# Add bdist builders for OSX
# Need exe because easy_install makes tests executable on 3.3
nipy_test_cmd = nptest_command('nipy', doctests=True, exe=True)
c['builders'].append(BuilderConfig(
    name='nipy-bdist-mpkg-2.7',
    slavenames=['osx-10.6'],
    factory=nipy_bot.bdist_factory(
        'egg',
        test_cmd=nipy_test_cmd,
        python='/Library/Frameworks/Python.framework/Versions/2.7/bin/python')
))
c['builders'].append(BuilderConfig(
    name='nipy-bdist-mpkg-3.3',
    slavenames=['osx-10.6'],
    factory=nipy_bot.bdist_factory(
        'egg',
        test_cmd=nipy_test_cmd,
        python='/Library/Frameworks/Python.framework/Versions/3.3/bin/python3')
))
##############################
# Dipy builders
##############################
# We have to jump through some difficult hoops to put the `dipnost` command on
# the path, because multiprocessing gets very unhappy if you try and run stuff
# from a command in a file that is not importable on the Python path, at least
# on Windows 32 bit
win32_dipy_test_cmd = ['python',  r'dipnost.py', 'dipy']
c['builders'].append(BuilderConfig(
    name='dipy-bdist32-26',
    slavenames=xp_32_slaves,
    factory=dipy_bot.bdist_factory(
        'exe',
        # Copy dipnost as py file into (later) working directory
        pre_build_cmds = [['copy', r'tools\dipnost', r'venv\dipnost.py']],
        test_cmd=win32_dipy_test_cmd,
        python=r'c:\Python26\python.exe')
))
c['builders'].append(BuilderConfig(
    name='dipy-bdist32-27',
    slavenames=xp_32_slaves,
    factory=dipy_bot.bdist_factory(
        'exe',
        # Copy dipnost as py file into (later) working directory
        pre_build_cmds = [['copy', r'tools\dipnost', r'venv\dipnost.py']],
        test_cmd=win32_dipy_test_cmd,
        python=r'c:\Python27\python.exe')
))
c['builders'].append(BuilderConfig(
    name='dipy-bdist32-32',
    slavenames=xp_32_slaves,
    factory=dipy_bot.bdist_factory(
        'exe',
        # Copy dipnost as py file into (later) working directory
        pre_build_cmds = [['copy', r'tools\dipnost', r'venv\dipnost.py']],
        test_cmd=win32_dipy_test_cmd,
        python=r'c:\Python32\python.exe')
))
# Add bdist builders for OSX
# Each of the tested _system_ pythons will need:
# * numpy, scipy, virtualenv, bdist_mpkg
osx_dipy_test_cmd = ['python',  '../tools/dipnost', '--exe', '--verbosity=3', 'dipy']
c['builders'].append(BuilderConfig(
    name='dipy-bdist-mpkg-2.7',
    slavenames=['osx-10.6'],
    factory=dipy_bot.bdist_factory(
        'egg',
        test_cmd=osx_dipy_test_cmd,
        python='/Library/Frameworks/Python.framework/Versions/2.7/bin/python')
))
c['builders'].append(BuilderConfig(
    name='dipy-bdist-mpkg-3.3',
    slavenames=['osx-10.6'],
    factory=dipy_bot.bdist_factory(
        'egg',
        test_cmd=osx_dipy_test_cmd,
        python='/Library/Frameworks/Python.framework/Versions/3.3/bin/python3')
))
# sympy binary builders
sympy_test_cmd = ['python', '-c',
                  'import sys; '
                  'import sympy; '
                  'open("matplotlibrc", "wt").write("backend : agg"); '
                  'dt=sympy.doctest(); '
                  't=sympy.test(); '
                  'sys.exit(not (dt and t))']
pip_deps = ('nose',)
for slavenames, bdist_suffix in (
    (xp_32_slaves, '32'),
    (win7_64_slaves, '64')):
    py2_name = 'sympy-bdist{0}-27'.format(bdist_suffix)
    py3_sched_name = 'sympy-bdist{0}-33-scheduler'.format(bdist_suffix)
    py3_build_name = 'sympy-bdist{0}-33-builder'.format(bdist_suffix)
    factory = sympy_bot.bdist_factory(
        'exe',
        test_cmd = sympy_test_cmd,
        pip_depends = pip_deps,
        python = r'c:\Python27\python.exe')
    factory.addStep(
            SetPropertyFromCommand(
                command=['python', 'bs_tools.py', 'get-tail', Property('bdist_file')],
                property='bdist_fname'))
    factory.addStep(
        Trigger(schedulerNames=[py3_sched_name],
                updateSourceStamp=True,
                set_properties={'bdist_fname' : Property('bdist_fname')}
            ))
    c['builders'].append(BuilderConfig(
        name=py2_name,
        slavenames=slavenames,
        factory=factory))
    # Make triggerable scheduler
    c['schedulers'].append(
            Triggerable(name=py3_sched_name, builderNames=[py3_build_name]))
    # Make builder for Python 3 bdist test
    factory = BuildFactory()
    env, workdir, venv_script_dir = sympy_bot._make_virtualenv(factory,
                                              'c:\Python33\python.exe')
    # Download bdist file
    factory.addStep(
        FileDownload(Interpolate(
            "public_html/" +
            sympy_bot.download_dir +
            "/%(prop:bdist_fname)s"),
            Property('bdist_fname'))
            )
    # easy_install bdist file into virtualenv
    factory.addStep(ShellCommand(
        command=['easy_install', Property('bdist_fname')],
        env=env))
    # pip install nose
    factory.addStep(ShellCommand(
        command=['pip', 'install', '--ignore-installed', 'nose'],
        env=env))
    # run tests
    factory.addStep(ShellCommand(
        command=sympy_test_cmd,
        env=env,
        workdir=workdir))
    c['builders'].append(BuilderConfig(
        name=py3_build_name,
        slavenames=slavenames,
        factory=factory))
# Make numpy wheels on 10.9, test on 10.6
building_slaves = osx_mountainlion_slaves
testing_slaves = osx_snowleopard_slaves
for python_bin, py_ver in (
        ('python', '2.7'),
        ('python3', '3.3'),
        ('python3', '3.4')):
    python_exe = '/Library/Frameworks/Python.framework/Versions/{0}/bin/{1}'.format(py_ver, python_bin)
    builder_name = 'numpy-bdist-whl-osx-' + py_ver
    tester_name = builder_name + '-downloaded'
    test_scheduler_name = tester_name + '-scheduler'
    factory = numpy_bot.bdist_factory('whl', python = python_exe)
    factory.addStep(
            SetPropertyFromCommand(
                command=['python', 'bs_tools.py', 'get-tail', Property('bdist_file')],
                property='bdist_fname'))
    factory.addStep(
        Trigger(schedulerNames=[test_scheduler_name],
                updateSourceStamp=True,
                set_properties={'bdist_fname' : Property('bdist_fname')}
            ))
    c['builders'].append(BuilderConfig(
        name=builder_name,
        slavenames=building_slaves,
        factory=factory))
    # Make triggerable scheduler
    c['schedulers'].append(
            Triggerable(name=test_scheduler_name, builderNames=[tester_name]))
    # Make downloading builder for other osx version
    factory = BuildFactory()
    env, workdir, venv_script_dir = numpy_bot._make_virtualenv(factory, python_exe)
    # Download bdist file
    factory.addStep(
        FileDownload(Interpolate(
            "public_html/" +
            numpy_bot.download_dir +
            "/%(prop:bdist_fname)s"),
            Property('bdist_fname'))
            )
    # Upgrade pip so it can use wheels
    factory.addStep(ShellCommand(
        command=['easy_install', '-U', 'pip'],
        env=env))
    # pip install bdist file into virtualenv
    factory.addStep(ShellCommand(
        command=['pip', 'install', Property('bdist_fname')],
        env=env))
    # pip install nose
    factory.addStep(ShellCommand(
        command=['pip', 'install', '--ignore-installed', 'nose'],
        env=env))
    # run tests
    factory.addStep(ShellCommand(
        command=numpy_bot.test_cmd,
        env=env,
        workdir=workdir))
    c['builders'].append(BuilderConfig(
        name=tester_name,
        slavenames=testing_slaves,
        factory=factory))

# Add nightly docs builders
c['builders'] += nipy_bot.build_doc_builders(
    (('nipy-doc-builder', linux_64_slaves),),
    doc_doctest_cmd = "cd doc && make doctest"
)
c['builders'] += nibabel_bot.build_doc_builders(
    (('nibabel-doc-builder', linux_64_slaves),))
c['builders'] += pandas_bot.build_doc_builders(
    (('pandas-doc-builder', sparc_slaves_sid),))
c['builders'] += statsmodels_bot.build_doc_builders(
    (('statsmodels-doc-builder', sparc_slaves_sid),))
c['builders'] += pymvpa_bot.build_doc_builders(
    (('pymvpa-doc-builder', sparc_slaves_sid),))

# pre-release builders
def inplace_cmd_factory(bot, commands, **kwargs):
    factory, env, workdir, buildir, venv_script_dir = \
      bot._code_build_factory(**kwargs)
    factory.addStep(ShellCommand(
        command=('python', 'setup.py', 'build_ext', '-i'),
        env=env))
    for cmd in commands:
        factory.addStep(ShellCommand(command=cmd, env=env))
    return factory

c['builders'].append(BuilderConfig(
    name='nipy-release-checks',
    slavenames=['osx-10.6'],
    factory=inplace_cmd_factory(nipy_bot,
        (('make', 'distclean'),
         ('python', '-m', 'compileall', '.'),
         ('make', 'sdist-tests'),
         ('make', 'bdist-egg-tests'),
         ('make', 'check-version-info'),
         ('make', 'check-files')),
                               )))
c['builders'].append(BuilderConfig(
    name='dipy-release-checks',
    slavenames=['osx-10.6'],
    factory=inplace_cmd_factory(dipy_bot,
        (('make', 'distclean'),
         ('python', '-m', 'compileall', '.'),
         ('make', 'sdist-tests'),
         ('make', 'bdist-egg-tests'),
         ('make', 'check-version-info'),
         ('make', 'check-files')),
        )))

# Example builders
c['builders'].append(BuilderConfig(
    name='nipy-examples-2.6',
    slavenames=['osx-10.6'],
    factory=example_factory(
        'git://github.com/nipy/nipy.git',
        '/Library/Frameworks/Python.framework/Versions/2.6',
        "nipy-examples-2.6")
))
c['builders'].append(BuilderConfig(
    name='nipy-examples-3.3',
    slavenames=['osx-10.6'],
    factory=example_factory(
        'git://github.com/nipy/nipy.git',
        '/Library/Frameworks/Python.framework/Versions/3.3',
        "nipy-examples-3.3",
        "python3")
))
# pip and easy_install builders
hours = 5
minutes = 0
for bot in (nibabel_bot, nipy_bot, dipy_bot):
    for pyver in ('2.7', '3.3'):
        project = bot.repo
        for install_cmd in (
                ('pip', 'install', '--ignore-installed', project),
                ('easy_install', '-U', project)):
            name_suff =  'py%s-%s' % (pyver, install_cmd[0])
            builder_name = '%s-%s' % (project, name_suff)
            # need nose dev version for fix to easy_install installations here:
            # https://github.com/nose-devs/nose/pull/661
            # When nose releases next version (after 1.3.0) can drop this
            if install_cmd[0] == 'easy_install':
                nose_target = 'git+git://github.com/nose-devs/nose.git'
            else:
                nose_target = 'nose'
            c['builders'] += bot.build_builders(
                ((builder_name, osx_mountainlion_slaves),),
                python='python' + pyver,
                easy_depends = (), # Turn off dependency install
                pip_depends = (nose_target,), # ditto
                install_cmd = install_cmd,
                install_wd = 'build/venv')
            c['schedulers'] += bot.nightly_scheduler(
                    [builder_name],
                    name_suff,
                    hours,
                    minutes,
                    True),
            minutes += 10
            if minutes == 60:
                hours += 1
                minutes = 0
# Code builders
c['builders'] += nibabel_bot.build_builders(
    (('nibabel-py2.6', linux_64_slaves),
     ('nibabel-py2.6-32', linux_32_slaves),
     ('nibabel-py2.7-osx-10.6', osx_snowleopard_slaves),
     ('nibabel-py2.7-osx-10.7', osx_lion_slaves),
     ('nibabel-py2.7-osx-10.8', osx_mountainlion_slaves),
     ('nibabel-py2.6-osx-10.5-ppc', osx_leopard_ppc_slaves),
     ('nibabel-py2.6-osx-10.5-intel', osx_leopard_intel_slaves),
     ('nibabel-py2.7-ppc', debian_ppc_slaves),
     ('nibabel-py2.6-arm', arm_slaves),
     ('nibabel-py2.7-fedora', fedora_slaves),
     ('nibabel-py2.6-xp', xp_32_slaves),
     ('nibabel-py2.7-win7', win7_64_slaves),
     ('nibabel-py2.6-squeeze-sparc', sparc_slaves),
     ('nibabel-py2.7-wheezy-sparc', sparc_slaves_wheezy),
     ('nibabel-py2.x-sid-sparc', sparc_slaves_sid)))
# Python 3s into virtualenv
c['builders'] += nibabel_bot.build_builders(
    (('nibabel-py3.2', linux_64_slaves),),
    python='python3.2')
c['builders'] += nibabel_bot.build_builders(
    (('nibabel-py3.3', osx_snowleopard_slaves),),
    python='python3.3')
# Different versions of Pydicom
c['builders'] += nibabel_bot.build_builders(
    (('nibabel-py2.7-pyd0.9.7', osx_mountainlion_slaves),),
    python='python2.7',
    pip_depends = ('nose', 'pydicom==0.9.7'))
c['builders'] += nibabel_bot.build_builders(
    (('nibabel-py2.7-pyd0.9.8', osx_mountainlion_slaves),),
    python='python2.7',
    pip_depends = ('nose', 'pydicom==0.9.8'))
# Nitime
c['builders'] += nitime_bot.build_builders(
    (('nitime-py2.6', linux_64_slaves),
     ('nitime-py2.6-32', linux_32_slaves),
     ('nitime-py2.7-osx-10.6', osx_snowleopard_slaves),
     ('nitime-py2.7-osx-10.7', osx_lion_slaves),
     ('nitime-py2.7-osx-10.8', osx_mountainlion_slaves),
     ('nitime-py2.6-osx-10.5-ppc', osx_leopard_ppc_slaves),
     ('nitime-py2.6-osx-10.5-intel', osx_leopard_intel_slaves),
     ('nitime-py2.6-arm', arm_slaves),
     ('nitime-py2.7-fedora', fedora_slaves),
     ('nitime-py2.6-xp', xp_32_slaves)))
# pyarbus
c['builders'] += pyarbus_bot.build_builders(
    (('pyarbus-py2.6', linux_64_slaves),))
c['builders'] += nipy_bot.build_builders(
    (('nipy-py2.6', linux_64_slaves),
     ('nipy-py2.6-32', linux_32_slaves),
     ('nipy-py2.7-osx-10.6', osx_snowleopard_slaves),
     ('nipy-py2.7-osx-10.7', osx_lion_slaves),
     ('nipy-py2.7-osx-10.8', osx_mountainlion_slaves),
     ('nipy-py2.6-osx-10.5-ppc', osx_leopard_ppc_slaves),
     ('nipy-py2.6-osx-10.5-intel', osx_leopard_intel_slaves),
     ('nipy-py2.7-ppc', debian_ppc_slaves),
     ('nipy-py2.6-arm', arm_slaves),
     ('nipy-py2.7-fedora', fedora_slaves),
     ('nipy-py2.6-xp', xp_32_slaves),
     ('nipy-py2.6-squeeze-sparc', sparc_slaves),
     ('nipy-py2.7-wheezy-sparc', sparc_slaves_wheezy),
     ('nipy-py2.x-sid-sparc', sparc_slaves_sid)))
# Python 3s into virtualenv
c['builders'] += nipy_bot.build_builders(
    (('nipy-py3.2', linux_64_slaves),),
    python='python3.2')
c['builders'] += nipy_bot.build_builders(
    (('nipy-py3.3', osx_snowleopard_slaves),),
    python='python3.3')
# Different versions of Sympy, nibabel
c['builders'] += nipy_bot.build_builders(
    (('nipy-py2.7-sym0.7.0-nib1.2.0', osx_mountainlion_slaves),),
    pip_depends = ('nose', 'sympy==0.7.0', 'nibabel==1.2.0'))
# The dipy builder seems to fail early sometimes, on OSX, maybe due to:
# http://bugs.python.org/issue8458
c['builders'] += dipy_bot_nox.build_builders(
    (('dipy-py2.6', linux_64_slaves),
     ('dipy-py2.6-32', linux_32_slaves),
))
c['builders'] += dipy_bot.build_builders((
     ('dipy-py2.7-osx-10.6', osx_snowleopard_slaves),
     ('dipy-py2.7-osx-10.7', osx_lion_slaves),
     ('dipy-py2.7-osx-10.8', osx_mountainlion_slaves),
     ('dipy-py2.6-osx-10.5-ppc', osx_leopard_ppc_slaves),
     ('dipy-py2.6-osx-10.5-intel', osx_leopard_intel_slaves),
     ('dipy-py2.6-arm', arm_slaves),
     ('dipy-py2.7-fedora', fedora_slaves),
     ('dipy-py2.6-xp', xp_32_slaves),
     ('dipy-py2.6-squeeze-sparc', sparc_slaves),
     ('dipy-py2.7-wheezy-sparc', sparc_slaves_wheezy),
     ('dipy-py2.x-sid-sparc', sparc_slaves_sid)))
# Python 3.2 into virtualenv
c['builders'] += dipy_bot.build_builders(
    (('dipy-py3.2', linux_64_slaves),),
    python='python3.2')
c['builders'] += dipy_bot.build_builders(
    (('dipy-py3.3', osx_snowleopard_slaves),),
    python='python3.3')
# Nipype
c['builders'] += nipype_bot.build_builders(
    (('nipype-py2.6', linux_64_slaves),
     ('nipype-py2.6-32', linux_32_slaves),
     ('nipype-py2.7-osx-10.6', osx_snowleopard_slaves),
     ('nipype-py2.7-osx-10.8', osx_mountainlion_slaves),
     ('nipype-py2.6-osx-10.5-ppc', osx_leopard_ppc_slaves),
     ('nipype-py2.6-osx-10.5-intel', osx_leopard_intel_slaves),
     ('nipype-py2.7-fedora', fedora_slaves),
     ('nipype-py2.6-xp', xp_32_slaves)))
c['builders'] += regreg_bot.build_builders(
    (('regreg-py2.6', linux_64_slaves),
     ('regreg-py2.6-32', linux_32_slaves),
     ('regreg-py2.7-osx-10.6', osx_snowleopard_slaves),
     ('regreg-py2.7-osx-10.7', osx_lion_slaves),
     ('regreg-py2.7-osx-10.8', osx_mountainlion_slaves),
     ('regreg-py2.6-osx-10.5-ppc', osx_leopard_ppc_slaves),
     ('regreg-py2.6-osx-10.5-intel', osx_leopard_intel_slaves),
     ('regreg-py2.7-fedora', fedora_slaves),
     ('regreg-py2.6-xp', xp_32_slaves)))
# Pandas - can be tested only on recent debian releases
c['builders'] += pandas_bot.build_builders(
    (('pandas-py2.x-sid-sparc', sparc_slaves_sid),
     ('pandas-py2.7-wheezy-sparc', sparc_slaves_wheezy)),
    post_cmds=("python -c 'from pandas.util.print_versions import show_versions; show_versions()'",))
# test on wheezy for python2.6
c['builders'] += pandas_bot.build_builders(
    (('pandas-py2.6-wheezy-sparc', sparc_slaves_wheezy),),
    python='python2.6')
# and python3 builders
c['builders'] += pandas_bot.build_builders(
    (('pandas-py3.x-sid-sparc', sparc_slaves_sid),
     ('pandas-py3.x-wheezy-sparc', sparc_slaves_wheezy)),
	post_cmds=("python3 -c 'from pandas.util.print_versions import show_versions; show_versions()'",),
    python='python3')
# Statsmodels - can be tested only on recent debian releases
c['builders'] += statsmodels_bot.build_builders(
    (('statsmodels-py2.x-sid-sparc', sparc_slaves_sid),
     ('statsmodels-py2.7-wheezy-sparc', sparc_slaves_wheezy)),
    post_cmds=("python -c 'from statsmodels.tools.print_version import show_versions; show_versions()'",))
## and python3 builders
#c['builders'] += statsmodels_bot.build_builders(
#    (('statsmodels-py3.x-sid-sparc', sparc_slaves_sid),
#     ('statsmodels-py3.x-wheezy-sparc', sparc_slaves_wheezy)),
#    python='python3')
# PyMVPA
c['builders'] += pymvpa_bot.build_builders(
    (('pymvpa-py2.x-sid-sparc', sparc_slaves_sid),
     ('pymvpa-py2.7-wheezy-sparc', sparc_slaves_wheezy),
     ('pymvpa-py2.7-osx-10.6', osx_snowleopard_slaves),
     ('pymvpa-py2.7-osx-10.7', osx_lion_slaves),
     ('pymvpa-py2.7-osx-10.8', osx_mountainlion_slaves),
     ('pymvpa-py2.6-osx-10.5-ppc', osx_leopard_ppc_slaves),
     ('pymvpa-py2.6-osx-10.5-intel', osx_leopard_intel_slaves),
     ('pymvpa-py2.6-xp', xp_32_slaves),
    ))
# Sklearn
c['builders'] += sklearn_bot.build_builders((
    ('sklearn-py2.x-sid-sparc', sparc_slaves_sid),))
c['builders'] += sklearn_bot.build_builders((
    ('sklearn-py2.6-wheezy-sparc', sparc_slaves_wheezy),),
    python='python2.6')
""" Disabling these guys; they haven't worked for a while
c['builders'].append(
    BuilderConfig(name="buildout-test2.6",
      slavenames=experimental,
      factory=factory_buildout_nibabel()))
c['builders'].append(
    BuilderConfig(name="buildout-test2.5",
      slavenames=experimental,
      factory=factory_buildout_nibabel('python2.5')))
c['builders'].append(
    BuilderConfig(name="buildout-test2.4",
      slavenames=experimental,
      factory=factory_buildout_nibabel('python2.4')))
"""
# Fail2ban
c['builders'] += fail2ban_bot.build_builders(
    (('fail2ban-py2.x-sid-sparc', sparc_slaves_sid),
     ('fail2ban-py2.7-wheezy-sparc', sparc_slaves_wheezy),
     ('fail2ban-py2.7-osx-10.6', osx_snowleopard_slaves),
     ('fail2ban-py2.7-osx-10.8', osx_mountainlion_slaves),
     ('fail2ban-py2.6-osx-10.5-ppc', osx_leopard_ppc_slaves),
     ('fail2ban-py2.6-osx-10.5-intel', osx_leopard_intel_slaves),
     ('fail2ban-py2.7-ppc', debian_ppc_slaves),
     ('fail2ban-py2.6-arm', arm_slaves),
     # ('fail2ban-py2.7-win7', win7_64_slaves),
    ),
    install_cmd=None)
# Sympy
c['builders'] += sympy_bot.build_builders(
    (('sympy-py2.6-32', linux_32_slaves),
    ))
c['builders'] += numpy_bot.build_builders(
    (('numpy-py2.7-osx-10.8', osx_mountainlion_slaves),
     ('numpy-py3.3-osx-10.8', osx_mountainlion_slaves),
     ('numpy-py3.4-osx-10.8', osx_mountainlion_slaves),
     ('numpy-py2.6-osx-10.5-ppc', osx_leopard_ppc_slaves),
    ))

# Assign all builders categories -- project names, to improve status visualizations
for b in c['builders']:
    b.category = b.name.split('-')[0]

# Add force scheduler to all builders
for b in c['builders']:
    c['schedulers'].append(ForceScheduler(name=b.name, builderNames=[b.name]))


####### STATUS TARGETS

# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.

c['status'] = []

from buildbot.status import html, mail
from buildbot.status.web import auth, authz

mn = mail.MailNotifier(fromaddr="buildbot@nipy.bic.berkeley.edu",
                      mode='failing',
                      categories=('sympy',),
                      sendToInterestedUsers=False,
                      extraRecipients=['asmeurer@gmail.com'])

c['status'].append(mn)

# Allow builds to be triggered via the web forms
sympy_release_filter = ChangeFilter(category="release", repository="sympy")
rel_sched = SingleBranchScheduler(name="sympy-release",
                                  change_filter=sympy_release_filter,
                                  builderNames=['sympy-bdist32-27',
                                                'sympy-bdist64-27']
                                 )
c['schedulers'].append(rel_sched)

http_auth = auth.HTPasswdAuth('bot_htpasswd')

authz_cfg=authz.Authz(
    auth = http_auth,
    # change any of these to True to enable; 'auth' to require authorization'
    # see the manual for more options
    gracefulShutdown = False,
    forceBuild = 'auth',
    forceAllBuilds = 'auth',
    pingBuilder = False,
    stopBuild = 'auth',
    stopAllBuilds = False,
    cancelPendingBuild = False,
)
c['status'].append(html.WebStatus(
    http_port=8010,
    authz=authz_cfg,
    change_hook_dialects={'base': True}
))

####### PROJECT IDENTITY
# the 'title' string will appear at the top of this buildbot
# installation's html.WebStatus home page (linked to the
# 'titleURL') and is embedded in the title of the waterfall HTML page.

c['title'] = "NiPy"
c['titleURL'] = "http://nipy.org"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server (usually the html.WebStatus page) is visible. This
# typically uses the port number set in the Waterfall 'status' entry, but
# with an externally-visible host name which the buildbot cannot figure out
# without some help.

c['buildbotURL'] = "http://nipy.bic.berkeley.edu/"

####### DB URL

# This specifies what database buildbot uses to store change and scheduler
# state.  You can leave this at its default for all but the largest
# installations.
c['db_url'] = "sqlite:///state.sqlite"

# Set mime types for server serving non buildbot files
from twisted.web.static import File
webdir = File("public_html")
webdir.contentTypes['.egg'] = 'application/octet-stream'
webdir.contentTypes['.whl'] = 'application/octet-stream'
